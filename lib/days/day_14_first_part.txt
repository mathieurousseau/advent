defmodule Day14 do
  @expected {"TBD", "TBD"}
  def run(input_1, input_2) do
    output_1 = first(input_1)

    output_2 = second(input_2)

    {{output_1, output_2}, @expected}
  end

  @doc """

  OOOO.#.O..
  OO..#....#
  OO..O##..O
  O..#.OO...
  ........#.
  ..#....#.#
  ..O..#.O.O
  ..O.......
  #....###..
  #....#....

  """

  defp first(input) do
    parse_input(input)
    |> Enum.map(&Enum.reverse(&1))
    |> Enum.map(&tilt(&1))
    |> Enum.map(&line_weight(&1))
    |> Enum.sum()
  end

  defp parse_input(input) do
    input
    |> String.split("\n")
    |> Enum.map(&String.graphemes(&1))
    |> transpose()

    # |> Enum.map(&String.graphemes(&1))
  end

  defp tilt(line) do
    # IO.puts(line)
    shift([], line, [])
    # IO.puts(line)
  end

  def transpose(lines) do
    lines
    |> Enum.reduce(%{}, fn line, acc ->
      line
      |> Enum.with_index()
      |> Enum.reduce(acc, fn {c, idx}, acc ->
        {_, acc} =
          Map.get_and_update(acc, idx, fn
            nil -> {nil, [c]}
            current -> {current, [c | current]}
          end)

        acc
      end)
    end)
    |> Enum.map(& &1)
    |> Enum.sort(fn {k, v}, {k2, v2} -> k < k2 end)
    |> Enum.map(fn {k, v} -> v end)
    |> Enum.map(&Enum.reverse(&1))

    # |> Enum.map(&Enum.join(&1))

    # |> Enum.reverse()
  end

  defp shift(rocks, [], new_line), do: new_line ++ rocks

  defp shift(rocks, [tile | rest], new_line) do
    case tile do
      "." ->
        shift(rocks, rest, new_line ++ [tile])

      "#" ->
        shift([], rest, new_line ++ rocks ++ [tile])

      "O" ->
        shift([tile | rocks], rest, new_line)
    end
  end

  defp line_weight(line) do
    line
    |> Enum.with_index()
    |> Enum.reduce(0, fn {c, idx}, acc ->
      if c == "O" do
        acc + 1 + idx
      else
        acc
      end
    end)
  end

  defp second(_input) do
  end
end
