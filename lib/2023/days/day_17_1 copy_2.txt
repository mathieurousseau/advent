defmodule Aoc2023.Day17One do
  @expected 94
  def run(input) do
    {do_run(input), @expected}
  end

  defp do_run(input) do
    # Agent.start_link(fn -> {%{}, MapSet.new()} end, name: :memo)

    {map, h, w} = Aoc.to_matrix(input, fn s -> String.to_integer(s) end)
    start_heat_loss = Map.get(map, {0, 0}) |> dbg
    Map.get(map, {h - 1, w - 1}) |> dbg
    # - start_heat_loss
    {_, ctx} = walk(map, {{0, 0}, :right, 0}, 0, h, w, nil, {%{}, MapSet.new(), nil})
    {_, {_, _, res_2}} = walk(map, {{0, 0}, :down, 0}, 0, h, w, nil, ctx)
    # {memo, visiting} = Agent.get(:memo, fn state -> state end)

    # memo
    # |> Enum.each(fn
    #   {{{0, 4}, _, _}, _} = m -> IO.inspect(m)
    #   _ -> nil
    # end)

    res_2
  end

  defp starter_min() do
  end

  defp walk(_, {{i, j}, _, _}, _, h, w, _, ctx) when i == -1 or j == -1 or i == h or j == w,
    do: {nil, ctx}

  defp walk(_, _, heat_loss, _, _, _min_heat_loss, {_memo, _visiting, min_heat_loss} = ctx)
       when heat_loss > min_heat_loss,
       do: {nil, ctx}

  defp walk(map, {{i, j} = point, _, _}, heat_loss, h, w, _, {memo, visiting, min_heat_loss})
       when i == h - 1 and j == w - 1 do
    tile_loss = Map.get(map, point)
    min_heat_loss = min(heat_loss + tile_loss, min_heat_loss)
    # if heat_loss + tile_loss == 19, do: raise("stop")
    {tile_loss, {memo, visiting, min_heat_loss}}
    # min(heat_loss + tile_loss, min_heat_loss)
  end

  defp walk(
         map,
         {point, to, times} = key,
         heat_loss,
         h,
         w,
         current_min,
         {memo, visiting, min_heat_loss} = originl_ctx
       ) do
    # {memo, visiting} = Agent.get(:memo, fn state -> state end)
    # IO.puts(map_size(memo))
    # IO.puts(MapSet.size(visiting))
    # IO.puts("")
    tile_loss = Map.get(map, point)
    prev = Map.get(memo, key)
    skip = MapSet.member?(visiting, key)
    # prev = nil

    cond do
      skip ->
        {nil, originl_ctx}

      not is_nil(prev) and prev <= heat_loss ->
        prev

      true ->
        # Agent.update(:memo, fn {memo, visiting} ->
        #   {memo, MapSet.put(visiting, key)}
        # end)

        visiting = MapSet.put(visiting, key)

        # if point == {0, 4} do
        # IO.puts(
        #   "#{inspect(point)} / #{to} / #{tile_loss} / #{times} / #{heat_loss} -> #{min_heat_loss}"
        # )

        # end

        # Process.sleep(500)

        {res, {memo, visiting, min_heat_loss}} =
          do_walk(
            map,
            {point, to, times},
            heat_loss,
            h,
            w,
            current_min,
            {memo, visiting, min_heat_loss}
          )

        # res = min(res, current_min)
        ctx = {Map.put(memo, key, res), MapSet.delete(visiting, key), min_heat_loss}
        # if point == {0, 4} do
        #   IO.inspect(res)
        # end

        {res, ctx}
    end
  end

  defp do_walk(map, {point, to, times} = key, heat_loss, h, w, _current_min, ctx) do
    tile_loss = Map.get(map, point)

    # if point == {0, 4} do
    #   IO.inspect(next_steps(point, times, from))
    # end

    {min_ahead, ctx} =
      next_steps(point, times, to)
      |> Enum.reduce({nil, ctx}, fn {n_point, n_to, n_times}, {current_min, ctx} ->
        case walk(map, {n_point, n_to, n_times}, tile_loss + heat_loss, h, w, current_min, ctx) do
          {nil, ctx} ->
            {nil, ctx}

          {this_min, ctx} ->
            {min(current_min, this_min), ctx}
        end
      end)

    # Agent.update(:memo, fn {memo, visiting} ->
    #   {Map.put(memo, key, min_ahead), MapSet.delete(visiting, key)}
    # end)
    if is_nil(min_ahead) do
      {nil, ctx}
    else
      {min_ahead + tile_loss, ctx}
    end
  end

  @directions [:down, :right, :up, :left]
  @opposites %{left: :right, right: :left, up: :down, down: :up}
  defp next_steps(point, times, to) do
    directions = List.delete(@directions, Map.get(@opposites, to))

    directions = if times == 3, do: List.delete(directions, to), else: directions

    Enum.map(directions, &next(&1, point, times, to))
  end

  defp next(to, {i, j} = _point, times, prev_to) do
    next_point =
      case to do
        :left -> {i, j - 1}
        :right -> {i, j + 1}
        :up -> {i - 1, j}
        :down -> {i + 1, j}
      end

    times = if to == prev_to, do: times + 1, else: 1
    {next_point, to, times}
  end
end
